\documentclass[10pt]{article}
\usepackage[utf8]{inputenc}

% Page setup
\usepackage[a3paper,landscape,margin=2cm]{geometry}

% Typography
\usepackage[T1]{fontenc}
\usepackage[scaled]{berasans}
\renewcommand*\familydefault{\sfdefault}
\usepackage{microtype}
\parindent 0pt

% TikZ
\usepackage{./tikz-uml}
\usetikzlibrary{positioning}

% Headings
\makeatletter
\def\@maketitle{%
  {\LARGE\bf\@title\par}
  \vskip .5em
  {\large\@author\ -- \@date\par}
  \vskip 2em
}
\makeatother

% Notes
\usepackage{multicol}
\newenvironment{Note}
  {\begin{multicols}{3}%
     \parskip 1em}
  {\end{multicols}%
   \medskip}

% Document metadata
\title{
  Solid server -- Proposed architecture v1.1.0
  \it (status: draft)
}
\author{Ruben Verborgh}

\begin{document}

\maketitle

\section*{Purpose}
This document conveys a~personal view
on important architectural considerations for a~Solid server.

It is intended as a~tool for discussion,
to raise questions,
and to highlight concerns.

It does not have any official standing whatsoever.

\newcommand\ResourceStoreBody{%
  + getRepresentation(ResourceIdentifier, RepresentationPreferences) : Promise<Representation>\\
  + addResource(container : ResourceIdentifier, Representation) : Promise<ResourceIdentifier>\\
  + setRepresentation(ResourceIdentifier, Representation) : Promise<void>\\
  + deleteResource(ResourceIdentifier) : Promise<void>\\
  + modifyResource(ResourceIdentifier, Patch) : Promise<void>\\
}

\section*{Overview of LDP and Access Control}
\begin{tikzpicture}

\begin{umlpackage}{HTTP}
  \umlinterface[]{HttpHandler}{}{
    + canHandle(HttpRequest) : Promise<boolean>\\
    + handle(HttpRequest, HttpResponse) : void\\
  }

  \umlclass[right=1 of HttpHandler]{HttpServer}{}{
    + HttpServer(Array<HttpHandler>)\\
    + listen(port : int) : void\\
    + handle(HttpRequest, HttpResponse) : void\\
  }
  \umluniaggreg[mult=*]{HttpServer}{HttpHandler}
\end{umlpackage}

\begin{umlpackage}[y=-4.5]{LDP}
  \umlclass{LdpHandler}{}{
    + LdpHandler(OperationFactory)\\
  }
  \umlimpl{LdpHandler}{HttpHandler}


  \umlsimpleclass[right=2 of LdpHandler.north east,anchor=south west]{TargetExtractor}
  \umluniaggreg[mult=1,anchor2=west]{LdpHandler}{TargetExtractor}

  \umlsimpleclass[right=2 of TargetExtractor]{ResourceIdentifier}
  \umldep[arg=creates,pos=0.5]{TargetExtractor}{ResourceIdentifier}


  \umlsimpleclass[below=0.25 of TargetExtractor.south east,anchor=north east]{BodyParser}
  \umluniaggreg[mult=*,anchor2=west]{LdpHandler}{BodyParser}

  \umlsimpleclass[below=0.25 of ResourceIdentifier.south west,anchor=north west]{Representation}
  \umldep[arg=creates,pos=0.5]{BodyParser}{Representation}

  \umlsimpleclass[right=1 of Representation]{Patch}
  \umlinherit{Patch}{Representation}


  \umlsimpleclass[below=0.25 of BodyParser.south east,anchor=north east]{PreferenceParser}
  \umluniaggreg[mult=1,anchor2=west]{LdpHandler}{PreferenceParser}

  \umlsimpleclass[below=0.25 of Representation.south west,anchor=north west]{RepresentationPreferences}
  \umldep[arg=creates,pos=0.5]{PreferenceParser}{RepresentationPreferences}


  \umlsimpleclass[below=0.25 of PreferenceParser.south east,anchor=north east]{ResponseWriter}
  \umluniaggreg[mult=1,anchor1=south east,anchor2=west]{LdpHandler}{ResponseWriter}

  \umlsimpleclass[below=0.25 of RepresentationPreferences.south west,anchor=north west]{HttpResponse}
  \umldep[arg=writes,pos=0.5]{ResponseWriter}{HttpResponse}


  \begin{umlpackage}[x=6,y=-4]{Operations}
    \umlclass[]{OperationFactory}{}{
      + OperationFactory(ResourceStore)\\
      + createOperation(method : string, ResourceIdentifier,\\*
                        RepresentationPreferences, \ldots) : Operation\\
    }
    \umluniaggreg[mult=1,geometry=|-]{LdpHandler}{OperationFactory}

    \umlinterface[below=1 of OperationFactory]{Operation}{
      + target : ResourceIdentifier\\
      + requestBody : Representation?\\
      + preferences : RepresentationPreferences\\
      + requiredPermissions : PermissionSet\\
    }{
      + execute() : Promise<ResponseDescription>\\
    }
    \umldep[arg=creates,pos=0.5]{OperationFactory}{Operation}

    \umlsimpleclass[right=1 of Operation.north east,anchor=north west]{GetOperation}
    \umlsimpleclass[below=.25 of GetOperation.south west,anchor=north west]{PostOperation}
    \umlsimpleclass[below=.25 of PostOperation.south west,anchor=north west]{PutOperation}
    \umlsimpleclass[below=.25 of PutOperation.south west,anchor=north west]{PatchOperation}
    \umlimpl[anchor1=west]{GetOperation}{Operation}
    \umlimpl[anchor1=west]{PostOperation}{Operation}
    \umlimpl[anchor1=west]{PutOperation}{Operation}
    \umlimpl[anchor1=west]{PatchOperation}{Operation}

  \end{umlpackage}
\end{umlpackage}

\begin{umlpackage}{Storage}
  \umlinterface[below=2.25 of Operation]{ResourceStore}{}{
    \ResourceStoreBody
  }
  \umluniaggreg[mult=1]{Operation}{ResourceStore}
\end{umlpackage}

\begin{umlpackage}{Authentication}
  \umlinterface[left=2 of LdpHandler.west]{CredentialsExtractor}{}{
    + extractCredentials(HttpRequest) : Promise<Credentials>\\
  }
  \umluniaggreg[mult=1]{LdpHandler}{CredentialsExtractor}

  \umlsimpleclass[below=1 of CredentialsExtractor]{Credentials}
  \umldep[arg=creates,pos=0.5]{CredentialsExtractor}{Credentials}
\end{umlpackage}

\begin{umlpackage}{Authorization}
  \umlinterface[below=4.5 of CredentialsExtractor]{Authorizer}{}{
    + hasPermissions(Credentials,
                     ResourceIdentifier,\\*
                     PermissionSet) : Promise<boolean>\\
  }
  \umldep[arg=uses,pos=0.3]{Authorizer}{Credentials}
  \umluniaggreg[mult=1,geometry=|-,weight=0.6]{LdpHandler}{Authorizer}

  \umlsimpleclass[below=1 of Authorizer]{AclBasedAuthorizer}
  \umlimpl{AclBasedAuthorizer}{Authorizer}
  \umluniaggreg[mult=1,geometry=|-]{AclBasedAuthorizer}{ResourceStore}
\end{umlpackage}

\end{tikzpicture}

\clearpage

\section*{Resources and Representations}
\begin{Note}
The intention of \textbf{ResourceIdentifier} and \textbf{Representation}
is to capture the REST notion of a~resource and its representation.
In~the~case of a~photograph,
the resource is the photograph itself,
whereas a~representation is a~concrete manifestation of that photograph
with a~certain resolution and file~type.
In~the~case of an RDF document,
the~resource is the RDF graph,
and concrete representations serialize that graph
into Turtle or specific framings of~JSON-LD.
\columnbreak

For all practical purposes,
\textbf{ResourceIdentifier} can just be a~\textbf{URL};
the terminology is mainly used to emphasize
the resource/representation notion of REST.
Also, there is no \textbf{Resource} class,
because resources are always manipulated through representations in REST,
so we only need to \emph{identify} resources,
and only deal with them through their representations.
\columnbreak

Crucially, as the diagram below shows,
the \textbf{Representation} interface
can have vastly different underlying in-memory structures,
such as strings, binary streams, RDF streams, etc.
So they can be photographs as well as RDF streams,
and most other classes handling them do not need to care.
This enables back-ends to be RDF-aware when they need to,
and RDF-oblivious when they do~not.
\end{Note}

\begin{tikzpicture}
  \umlinterface{Representation}{
    + identifier : ResourceIdentifier?\\
    + metadata : RepresentationMetadata\\
    + data : Readable<Object>\\
    + dataType : String\\
  }{}

  \umlinterface[left=2 of Representation]{ResourceIdentifier}{
  }{}
  \umluniaggreg[mult=0..1]{Representation}{ResourceIdentifier}

  \umlinterface[below=2 of Representation]{RepresentationMetadata}{
    + byteSize : int?\\
    + contentType : String?\\
    + encoding : String?\\
    + language : String?\\
    + dateTime : Date?\\
    + profiles : Array<String>\\
  }{}
  \umluniaggreg[mult=1]{Representation}{RepresentationMetadata}

  \umlclass[right=2 of Representation.north east]{BinaryRepresentation}{
    + data : Readable<Buffer>\\
  }{}
  \umlimpl{BinaryRepresentation}{Representation}

  \umlclass[right=2 of Representation.south east]{QuadRepresentation}{
    + data : Readable<Quad>\\
  }{}
  \umlimpl{QuadRepresentation}{Representation}

\end{tikzpicture}

\clearpage

\section*{Example classes and interfaces deriving from ResourceStore}
\begin{tikzpicture}
  \umlinterface{ResourceStore}{}{\ResourceStoreBody}


  % FileSystemStore

  \umlclass[right=3 of ResourceStore]{FileSystemStore}{
    - ResourceMapper mapper\\
  }{}
  \umlimpl{FileSystemStore}{ResourceStore}

  \umlinterface[right=2 of FileSystemStore]{ResourceMapper}{}{
    + mapFilePathToUrl(File): Promise<\{URL, RepresentationMetadata\}>\\
    + mapUrlToFilePath(URL, RepresentationMetadata): Promise<File>\\
  }
  \umluniaggreg[mult=1]{FileSystemStore}{ResourceMapper}


  % KeyValueStore

  \umlabstract[above=4.5 of FileSystemStore.south west,anchor=west]{KeyValueStore}{}{
    + get(ResourceIdentifier) : Promise<BinaryRepresentation>\\
    + replace(ResourceIdentifier, BinaryRepresentation) : Promise<void>\\
    + delete(ResourceIdentifier) : Promise<void>\\
  }
  \umlimpl{KeyValueStore}{ResourceStore}

  \umlsimpleclass[right=2 of KeyValueStore.north east]{RedisStore}
  \umlinherit{RedisStore}{KeyValueStore}

  \umlsimpleclass[right=2 of KeyValueStore.east]{CassandraStore}
  \umlinherit{CassandraStore}{KeyValueStore}


  % TripleStore

  \umlclass[below=2.3 of FileSystemStore.south west,anchor=west]{TripleStore}{}{
    + TripleStore(endpoint: URL)\\
  }
  \umlimpl{TripleStore}{ResourceStore}

\end{tikzpicture}

\end{document}
